      
 void casevois(int x, int y, int d, int *nx, int *ny)
{
 
   if (d == 0) {           /*nord*/
        *nx = x;
        *ny = y - 1;
    } else if (d == 1) {     /*est*/
        *nx = x + 1;
        *ny = y;
    } else if (d == 2) {    /*sud*/
        *nx = x;
        *ny = y + 1;
    } else if (d == 3) {    /*ouest*/
        *nx = x - 1;
        *ny = y;
    } else {          
        *nx = x;
        *ny = y;
    }
}   /*  on depasse les limites du tableaux */

void phaseExpansion(int lab[TAILLE_X][TAILLE_Y], int xD, int yD, int xA, int yA) {
    int r = 1;
    lab[xD][yD] = r;
}

    /* Initialisation affichage */
    if (!initAffichage()) {
        fprintf(stderr, "Erreur lors de l'initialisation de l'affichage\n");
        return 1;
    }

/*
  Question 5 :

  Si on cherche à utiliser la fonction `coord_case_voisine` pour une case
  située sur le bord du tableau (coordonnées x=0, x=TAILLE_X-1, y=0, y=TAILLE_Y-1), 
  certaines directions pointeraient **hors du tableau** :

    - Nord d'une case y=0 → ny = -1 (hors limites)
    - Sud d'une case y=TAILLE_Y-1 → ny = TAILLE_Y (hors limites)
    - Ouest d'une case x=0 → nx = -1 (hors limites)
    - Est d'une case x=TAILLE_X-1 → nx = TAILLE_X (hors limites)

  Cela provoquerait **un accès mémoire invalide** si on essayait de lire/écrire
  dans le tableau avec ces coordonnées.

  Pour se prémunir de ce problème sans complexifier l'algorithme,
  on considère que toutes les cases de la périphérie du labyrinthe sont bloquées,
  et donc on n'appellera pas la fonction coord_case_voisine depuis une case
  située sur la bordure.
*/
