      
 void casevois(int x, int y, int d, int *nx, int *ny)
{
 
   if (d == 0) {           /*nord*/
        *nx = x;
        *ny = y - 1;
    } else if (d == 1) {     /*est*/
        *nx = x + 1;
        *ny = y;
    } else if (d == 2) {    /*sud*/
        *nx = x;
        *ny = y + 1;
    } else if (d == 3) {    /*ouest*/
        *nx = x - 1;
        *ny = y;
    } else {          
        *nx = x;
        *ny = y;
    }
}   /*  on depasse les limites du tableaux */

void phaseExpansion(int lab[TAILLE_X][TAILLE_Y], int xD, int yD, int xA, int yA) {
    int r = 1;
    lab[xD][yD] = r;
}

    /* Initialisation affichage */
    if (!initAffichage()) {
        fprintf(stderr, "Erreur lors de l'initialisation de l'affichage\n");
        return 1;
    }

/*
  Question 5 :

  Si on cherche à utiliser la fonction `coord_case_voisine` pour une case
  située sur le bord du tableau (coordonnées x=0, x=TAILLE_X-1, y=0, y=TAILLE_Y-1), 
  certaines directions pointeraient **hors du tableau** :

    - Nord d'une case y=0 → ny = -1 (hors limites)
    - Sud d'une case y=TAILLE_Y-1 → ny = TAILLE_Y (hors limites)
    - Ouest d'une case x=0 → nx = -1 (hors limites)
    - Est d'une case x=TAILLE_X-1 → nx = TAILLE_X (hors limites)

  Cela provoquerait **un accès mémoire invalide** si on essayait de lire/écrire
  dans le tableau avec ces coordonnées.

  Pour se prémunir de ce problème sans complexifier l'algorithme,
  on considère que toutes les cases de la périphérie du labyrinthe sont bloquées,
  et donc on n'appellera pas la fonction coord_case_voisine depuis une case
  située sur la bordure.
*/




/*
void phaseExpansion(int tab_representative_labyrinthe[TAILLE_X][TAILLE_Y], int coord_x_depart, int coord_y_depart, int coord_x_arrivee, int coord_y_arrivee)
{
    int distance_parouru = 1; // distance initiale correspondant au r présent dans la question 6
    int changements = 1; // pour savoir si de nouvelles cases ont été marquées

    tab_representative_labyrinthe[coord_x_depart][coord_y_depart] = distance_parouru; // on marque la case de départ

    while (tab_representative_labyrinthe[coord_x_arrivee][coord_y_arrivee] == 0 && changements) { // tant que l'arrivée n'est pas atteinte
        changements = 0;

        // on parcourt toutes les cases
        for (int y = 1; y < TAILLE_Y - 1; y++) {      // on ignore les bordures
            for (int x = 1; x < TAILLE_X - 1; x++) {

                if (tab_representative_labyrinthe[x][y] == distance_parouru) { // case marquée r
                    // vérifier les 4 voisins
                    for (int d = 0; d < 4; d++) {
                        int nx, ny;
                        coord_case_voisine(x, y, d, &nx, &ny);

                        if (tab_representative_labyrinthe[nx][ny] == 0) { // case libre non visitée
                            tab_representative_labyrinthe[nx][ny] = distance_parouru + 1;
                            changements = 1;
                        }
                    }
                }
            }
        }

        distance_parouru++; // incrémenter la distance
    }
}
*/
